#   集合

###  集合使用的回顾
* A:集合使用的回顾
	* a.ArrayList集合存储5个int类型元素
      ```java
        public static void main(String[] args) {
            ArrayList<Integer> list = new ArrayList<Integer>();
            list.add(111);
            list.add(222);
            list.add(333);
            list.add(444);
            list.add(555);
            for(int i=0; i<list.size(); i++){
                   System.out.println(list.get(i));
           }
        }
      ```

    * b.ArrayList集合存储5个Person类型元素
      ```java
        public static void main(String[] args) {
            ArrayList<Person> list = new ArrayList<Person>();
            list.add(new Person(“小强”));
            list.add(new Person(“老王”));
            list.add(new Person(“小虎”));
            list.add(new Person(“小泽”));
            list.add(new Person(“小红”));
            for(int i=0; i<list.size(); i++){
                Person p = list.get(i);
                System.out.println(p);
            }
        }
      ```
- - - 

###  集合的学习目标
* 集合，集合是java中提供的一种容器，可以用来存储多个数据。
    * 在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，它们有啥区别呢？
        *   数组的长度是固定的。集合的长度是可变的。
        *   集合中存储的元素必须是引用类型数据
- - - 

###  集合继承关系图
* A:集合继承关系图
    * a:ArrayList的继承关系:
        查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口。Collection接口为最顶层集合接口了。
        ```java
        源代码：
            interface List extends Collection {
            }
                public class ArrayList extends AbstractList implements List{
                }
        ```

    * b:集合继承体系
        这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。那么，实现Collection接口的所有子类都会进行方法重写。
        * Collecton接口常用的子接口有：List接口、Set接口
        * List接口常用的子类有：ArrayList类、LinkedList类
        * Set接口常用的子类有：HashSet类、LinkedHashSet类
        ```
                                     Collection 接口     
                                           |
             -------------------------------------------------------
             |                                                     |
            List接口                                             Set接口
             |                                                     |
         ----------------                                     -------------
         |              |                                    |            |
        ArrayList类    LinkedList类                     HashSet类     LinkedHashSet类
        ```
- - - 

###  集合Collection的方法
* A:集合Collection的方法
    ```java
     /*
      *  Collection接口中的方法
      *  是集合中所有实现类必须拥有的方法
      *  使用Collection接口的实现类,程序的演示
      *  ArrayList implements List
      *  List extends Collection
      *  方法的执行,都是实现的重写
      */
     public class CollectionDemo {
      public static void main(String[] args) {
        function_2();
      }
      
      
      /*  Collection接口方法
       *  Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组
       *  返回是一个存储对象的数组, 数组存储的数据类型是Object
       */
      private static void function_2() {
        Collection<String> coll = new ArrayList<String>();
        coll.add("abc");
        coll.add("itcast");
        coll.add("itheima");
        coll.add("money");
        coll.add("123");
        
        Object[] objs = coll.toArray();
        for(int i = 0 ; i < objs.length ; i++){
          System.out.println(objs[i]);
        }
      }
      /*
       * 学习Java中三种长度表现形式
       *   数组.length 属性  返回值 int
       *   字符串.length() 方法,返回值int
       *   集合.size()方法, 返回值int
       */
      
      /*
       * Collection接口方法
       * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true
       * 方法参数是Object类型
       */
      private static void function_1() {
        Collection<String> coll = new ArrayList<String>();
        coll.add("abc");
        coll.add("itcast");
        coll.add("itheima");
        coll.add("money");
        coll.add("123");
        
        boolean b = coll.contains("itcast");
        System.out.println(b);
      }


      /*
       * Collection接口的方法
       * void clear() 清空集合中的所有元素
       * 集合容器本身依然存在
       */
      public static void function(){
        //接口多态的方式调用
        Collection<String> coll = new ArrayList<String>();
        coll.add("abc");
        coll.add("bcd");
        System.out.println(coll);
        
        coll.clear();
        
        System.out.println(coll);
        
      }
     }
    ```
- - - 

###  集合Collection的remove方法
* A:05集合Collection的remove方法
    ```java
    /*
     * Collection接口方法
     * boolean remove(Object o)移除集合中指定的元素
     */
    private static void function_3(){
      Collection<String> coll = new ArrayList<String>();
      coll.add("abc");
      coll.add("money");
      coll.add("itcast");
      coll.add("itheima");
      coll.add("money");
      coll.add("123");  
      System.out.println(coll);
      
      boolean b = coll.remove("money");
      System.out.println(b);
      System.out.println(coll);
    }
    ```
- - - 

##  Iterator迭代器
- - - 

###  迭代器的概述
* A:迭代器概述:
    * a:java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。
        我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。
   
    * b:Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，
     如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。
   
    * c:每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用那种集合,我们都会有判断是否有元素
    以及取出里面的元素的动作,那么Java为我们提供一个迭代器定义了统一的判断元素和取元素的方法 
- - - 

###  迭代器的实现原理
* A:迭代器的实现原理
    ```java
	  /*
     *  集合中的迭代器:
     *    获取集合中元素方式
     *  接口 Iterator : 两个抽象方法
     *     boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true
     *     next() 取出集合中的下一个元素
     *     
     *  Iterator接口,找实现类.
     *    Collection接口定义方法 
     *       Iterator  iterator()
     *    ArrayList 重写方法 iterator(),返回了Iterator接口的实现类的对象
     *    使用ArrayList集合的对象
     *     Iterator it =array.iterator(),运行结果就是Iterator接口的实现类的对象
     *     it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代
     */
    ```
- - - 

###  迭代器的代码实现
* A:迭代器的代码实现
    ```java
      public class IteratorDemo {
        public static void main(String[] args) {
          Collection<String> coll = new ArrayList<String>();
          coll.add("abc1");
          coll.add("abc2");
          coll.add("abc3");
          coll.add("abc4");
          //迭代器,对集合ArrayList中的元素进行取出
          
          //调用集合的方法iterator()获取出,Iterator接口的实现类的对象
          Iterator<String> it = coll.iterator();
          //接口实现类对象,调用方法hasNext()判断集合中是否有元素
          //boolean b = it.hasNext();
          //System.out.println(b);
          //接口的实现类对象,调用方法next()取出集合中的元素
          //String s = it.next();
          //System.out.println(s);
          
          //迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false
          while(it.hasNext()){
            String s = it.next();
            System.out.println(s);
          }
           
        }
      }
    ```
- - - 

###  迭代器的执行过程
* A:迭代器的执行过程
    * a:迭代器的原理:
    ```java
       while(it.hasNext()) {
            System.out.println(it.next());
       }
       
       //cursor记录的索引值不等于集合的长度返回true,否则返回false
         public boolean hasNext() {       
           return cursor != size; //cursor初值为0
                           
         }

        //next()方法作用:
        //①返回cursor指向的当前元素 
        //②cursor++
        public Object next() {            
                 int i = cursor; 
                 cursor = i + 1;  
                 return  elementData[lastRet = i]; 
             
             }
    ```

    * b:for循环迭代写法:
    ```java
        for (Iterator<String> it2 = coll.iterator(); it2.hasNext();  ) {
         System.out.println(it2.next());
       } 
    ```
- - - 

###  集合迭代中的转型 
* A:集合迭代中的转型
    * a:在使用集合时，我们需要注意以下几点：
        集合中存储其实都是对象的地址。
        集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。
        因为出现了基本类型包装类，它提供了自动装箱操作（基本类型对象），这样，集合中的元素就是基本数值的包装类对象。
    
    * b:存储时提升了Object。取出时要使用元素的特有内容，必须向下转型。
    ```java
     Collection coll = new ArrayList();
     coll.add("abc");
     coll.add("aabbcc");
     coll.add("shitcast");
     Iterator it = coll.iterator();
     while (it.hasNext()) {
      //由于元素被存放进集合后全部被提升为Object类型
     //当需要使用子类对象特有方法时，需要向下转型
      String str = (String) it.next();
      System.out.println(str.length());
     }
     注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。
    ```
    
    * c:Iterator接口也可以使用<>来控制迭代元素的类型的。代码演示如下：
    ```java
     Collection<String> coll = new ArrayList<String>();
     coll.add("abc");
     coll.add("aabbcc");
     coll.add("shitcast");
     Iterator<String> it = coll.iterator();
     while (it.hasNext()) {
      String str =  it.next(); 
     //当使用Iterator<String>控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
      System.out.println(str.length());
     }
    ```
- - - 

##  增强for循环
- - - 

###  增强for循环遍历数组
* A:增强for循环遍历数组
    * a:格式:
    ```java
     /*
      *  JDK1.5新特性,增强for循环
      *  JDK1.5版本后,出现新的接口 java.lang.Iterable
      *    Collection开是继承Iterable
      *    Iterable作用,实现增强for循环
      *    
      *    格式:
      *      for( 数据类型  变量名 : 数组或者集合 ){
      *         sop(变量);
      *      }
      */
     public static void function_1(){
        //for对于对象数组遍历的时候,能否调用对象的方法呢
        String[] str = {"abc","itcast","cn"};
        for(String s : str){
          System.out.println(s.length());
        }
      }
      
      /*
       *  实现for循环,遍历数组
       *  好处: 代码少了,方便对容器遍历
       *  弊端: 没有索引,不能操作容器里面的元素
       */
      public static void function(){
        int[] arr = {3,1,9,0};
        for(int i : arr){
          System.out.println(i+1);
        }
        System.out.println(arr[0]);
      }
    ```
- - - 

###  增强for循环遍历集合 
* A:增强for循环遍历集合  
    ```java
        /*
         *  增强for循环遍历集合
         *  存储自定义Person类型
         */
        public static void function_2(){
          ArrayList<Person> array = new ArrayList<Person>();
          array.add(new Person("a",20));
          array.add(new Person("b",10));
          for(Person p : array){
            System.out.println(p);// System.out.println(p.toString());
          }
        }
    ```
- - - 

##  泛型
- - - 

###  泛型的引入 
* A:泛型的引入
    * 在前面学习集合时，我们都知道集合中是可以存放任意对象的，
        只要把对象存储集合后，那么这时他们都会被提升成Object类型。
        当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。比如下面程序：
    ```java    
    public class GenericDemo {
      public static void main(String[] args) {
        List list = new ArrayList();
        list.add("abc");
        list.add("itcast");
        list.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放
                    //相当于:Object obj=new Integer(5);
        
        Iterator it = list.iterator();
        while(it.hasNext()){
          //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型
          String str = (String) it.next();//String str=(String)obj;
                                          //编译时期仅检查语法错误,String是Object的儿子可以向下转型
                                          //运行时期String str=(String)(new Integer(5))
                                          //String与Integer没有父子关系所以转换失败
                                          //程序在运行时发生了问题java.lang.ClassCastException
          System.out.println(str.length());
        }
      }
    }
    ```
- - -     

###  泛型的定义和使用
* A:泛型的定义和使用
    ```java
    /*
     * JDK1.5 出现新的安全机制,保证程序的安全性
     *   泛型: 指明了集合中存储数据的类型  <数据类型>
     */

    public class GenericDemo {
      public static void main(String[] args) {
        function();
      }
      
      public static void function(){
        Collection<String> coll = new ArrayList<String>();
        coll.add("abc");
        coll.add("rtyg");
        coll.add("43rt5yhju");
    //    coll.add(1);
        
        Iterator<String> it = coll.iterator();
        while(it.hasNext()){
          String s = it.next();
          System.out.println(s.length());
        }
      }
    }
    ```
- - - 

###  Java中的伪泛型
* A:Java中的伪泛型：
    ```java
    泛型只在编译时存在,编译后就被擦除,在编译之前我们就可以限制集合的类型,起到作用
    例如:ArrayList<String> al=new ArrayList<String>();
    编译后:ArrayList al=new ArrayList();
    ```
- - - 

###  泛型类
* A:泛型类:
    * a:定义格式：
    ```java
      修饰符 class 类名<代表泛型的变量> {  }
      
      例如，API中的ArrayList集合：
      class ArrayList<E>{ 
           public boolean add(E e){ }
        public E get(int index){  }
      }
    ```

    * b:使用格式：
    ```java
      创建对象时，确定泛型的类型
     
      例如，ArrayList<String> list = new ArrayList<String>();
      此时，变量E的值就是String类型
      class ArrayList<String>{ 
        public boolean add(String e){ }
        public String get(int index){  }
      }
     
      例如，ArrayList<Integer> list = new ArrayList<Integer>();
      此时，变量E的值就是Integer类型
      class ArrayList<Integer>{ 
           public boolean add(Integer e){ }
           public Integer get(int index){  }
      }
    ```
- - - 

###  泛型的方法
* A:泛型的方法
    * a:定义格式：修饰符 <代表泛型的变量> 返回值类型 方法名(参数){  }
    * b:泛型方法的使用:
    ```java
     1:例如，API中的ArrayList集合中的方法：
      public <T> T[] toArray(T[] a){  } 
      //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组

      使用格式：调用方法时，确定泛型的类型
    例如:
          ArrayList<String> list = new ArrayList<String>();
          String[] arr = new String[100];
          String[] result = list.toArray(arr);
       此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同
       public <String> String[] toArray(String[] a){  } 
    

      例如:
          ArrayList<String> list = new ArrayList<String>();
          Integer[] arr = new Integer[100];
          Integer [] result = list.toArray(arr);
      
      此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同
      public <Integer> Integer[] toArray(Integer[] a){  } 
    ```
- - - 

###  泛型的接口 
* A:泛型的接口:
    ```java 
     /*
      *  带有泛型的接口
      *  
      *  public interface List <E>{
      *    abstract boolean add(E e);
      *  }
      * 
      *  实现类,先实现接口,不理会泛型
      *  public class ArrayList<E> implements List<E>{
      *  }
      *  调用者 : new ArrayList<String>() 后期创建集合对象的时候,指定数据类型
      *  
      *  
      *  实现类,实现接口的同时,也指定了数据类型
      *  public class XXX implements List<String>{
      *  }
      *  new XXX()
      */
     public class GenericDemo2 {
      
     }
    ```
- - - 

###  泛型的好处
*   A:泛型的好处
    * a:将运行时期的ClassCastException，转移到了编译时期变成了编译失败。
    * b:避免了类型强转的麻烦。
    ```java
    演示下列代码：
    public class GenericDemo {
      public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        list.add("abc");
        list.add("itcast");
        //list.add(5);//当集合明确类型后，存放类型不一致就会编译报错
                     //集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型
       
        Iterator<String> it = list.iterator();
        while(it.hasNext()){
           String str = it.next();
           System.out.println(str.length()); //当使用Iterator<String>      
                                            //控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
        }
      }
    }
    ```
- - - 

###  泛型的通配符   
* A:泛型的通配符
```java
   /*
    *  泛型的通配符
    */
   public class GenericDemo {
    public static void main(String[] args) {
      ArrayList<String> array = new ArrayList<String>();
      
      HashSet<Integer> set = new HashSet<Integer>();
      
      array.add("123");
      array.add("456");
      
      set.add(789);
      set.add(890);
      
      iterator(array);
      iterator(set);
    }
    /*
     *  定义方法,可以同时迭代2个集合
     *  参数: 怎么实现 , 不能写ArrayList,也不能写HashSet
     *  参数: 或者共同实现的接口
     *  泛型的通配,匹配所有的数据类型  ?
     */
    public static void iterator(Collection<?> coll){
      Iterator<?> it = coll.iterator();
      while(it.hasNext()){
        //it.next()获取的对象,什么类型
        System.out.println(it.next());
      }
    }
   }
```
- - - 

###  泛型的限定 
* A:泛型的限定
```java  
   /*
    *  将的酒店员工,厨师,服务员,经理,分别存储到3个集合中
    *  定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法
    */
   import java.util.ArrayList;
   import java.util.Iterator;
   public class GenericTest {
    public static void main(String[] args) {
      //创建3个集合对象
      ArrayList<ChuShi> cs = new ArrayList<ChuShi>();
      ArrayList<FuWuYuan> fwy = new ArrayList<FuWuYuan>();
      ArrayList<JingLi> jl = new ArrayList<JingLi>();
      
      //每个集合存储自己的元素
      cs.add(new ChuShi("张三", "后厨001"));
      cs.add(new ChuShi("李四", "后厨002"));
      
      fwy.add(new FuWuYuan("翠花", "服务部001"));
      fwy.add(new FuWuYuan("酸菜", "服务部002"));
      
      jl.add(new JingLi("小名", "董事会001", 123456789.32));
      jl.add(new JingLi("小强", "董事会002", 123456789.33));
      
   //   ArrayList<String> arrayString = new ArrayList<String>();
      iterator(jl);
      iterator(fwy);
      iterator(cs);
    
    }
    /*
     * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work
     * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法
     * 强制转换:  it.next()=Object o ==> Employee
     * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象
     * 泛型的限定  本案例,父类固定Employee,但是子类可以无限?
     *   ? extends Employee 限制的是父类, 上限限定, 可以传递Employee,传递他的子类对象
     *   ? super   Employee 限制的是子类, 下限限定, 可以传递Employee,传递他的父类对象
     */
    public static void iterator(ArrayList<? extends Employee> array){
      
       Iterator<? extends Employee> it = array.iterator();
       while(it.hasNext()){
         //获取出的next() 数据类型,是什么Employee
         Employee e = it.next();
         e.work();
       }
    }
   }
```
- - - 

##  List接口
- - - 

###  List接口的特点
* A:List接口的特点:
    * a:它是一个元素存取有序的集合。
        例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。
    * b:它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。

    * c:集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。

    * d:List接口的常用子类有：
        * ArrayList集合
        * LinkedList集合
- - - 

###  List接口的特有方法
* A:List接口的特有方法(带索引的方法)
    * a:增加元素方法
        * add(Object e)：向集合末尾处，添加指定的元素 
        * add(int index, Object e)   向集合指定索引处，添加指定的元素，原有元素依次后移
    ```java 
     /*
       *  add(int index, E)
       *  将元素插入到列表的指定索引上
       *  带有索引的操作,防止越界问题
       *  java.lang.IndexOutOfBoundsException
       *     ArrayIndexOutOfBoundsException
       *     StringIndexOutOfBoundsException
       */
      public static void function(){
        List<String> list = new ArrayList<String>();
        list.add("abc1");
        list.add("abc2");
        list.add("abc3");
        list.add("abc4");
        System.out.println(list);
        
        list.add(1, "itcast");
        System.out.println(list);
      }
    ```

    * b:删除元素删除
        * remove(Object e)：将指定元素对象，从集合中删除，返回值为被删除的元素
        * remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素
    ```java
     /*
       *  E remove(int index)
       *  移除指定索引上的元素
       *  返回被删除之前的元素
       */
      public static void function_1(){
        List<Double> list = new ArrayList<Double>();
        list.add(1.1);
        list.add(1.2);
        list.add(1.3);
        list.add(1.4);
        
        Double d = list.remove(0);
        System.out.println(d);
        System.out.println(list);
      }
    ```

    * c:替换元素方法
    ```java
    set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素
      /*
       *  E set(int index, E)
       *  修改指定索引上的元素
       *  返回被修改之前的元素
       */
      public static void function_2(){
        List<Integer> list = new ArrayList<Integer>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        
        Integer i = list.set(0, 5);
        System.out.println(i);
        System.out.println(list);
      }
    ```

    * d:查询元素方法
        * get(int index)：获取指定索引处的元素，并返回该元素
- - - 

###  迭代器的并发修改异常
* A:迭代器的并发修改异常
    ```java
     /*
      *  迭代器的并发修改异常 java.util.ConcurrentModificationException
      *  就是在遍历的过程中,使用了集合方法修改了集合的长度,不允许的
      */
     public class ListDemo1 {
      public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        list.add("abc1");
        list.add("abc2");
        list.add("abc3");
        list.add("abc4");
        
        //对集合使用迭代器进行获取,获取时候判断集合中是否存在 "abc3"对象
        //如果有,添加一个元素 "ABC3"
        Iterator<String> it = list.iterator();
        while(it.hasNext()){
          String s = it.next();
          //对获取出的元素s,进行判断,是不是有"abc3"
          if(s.equals("abc3")){
            list.add("ABC3");
          }
          System.out.println(s);
        }
      }
     }
    ```
     运行上述代码发生了错误 java.util.ConcurrentModificationException这是什么原因呢？
       在迭代过程中，使用了集合的方法对元素进行操作。
       导致迭代器并不知道集合中的变化，容易引发数据的不确定性。
       
     并发修改异常解决办法：
        在迭代时，不要使用集合的方法操作元素。
        或者通过ListIterator迭代器操作元素是可以的，ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。
- - - 

#### 并发修改异常(重点)
    描述的是：集合和迭代器同时持有同一个对象，当集合在添加，和删除集合元素时（修改呢），迭代器并不知道，所以会发生并发修改异常   
    注意：增强for也会产生并发修改异常
    如何解决： 第一： 使用普通for循环
              第二(重点):使用listIterator -->是List 特有的，其他集合不能使用  
    代码：

#### 常用方法：
      a、 E set(int index, E) 修改指定索引上的元素，返回被修改之前的元素
      b、 E remove(int index) 移除指定索引上的元素，返回被删除之前的元素
      c、 add(int index, E)将元素插入到列表的指定索引上，其他元素顺移
      d、remove(int index) 删除并返回元素
             
#### 数据类型：
     栈   ： 手枪的弹夹 : 手枪的压栈     ---> 喝酒   --->先进后出，后进先出
     队列 :  超市的购物，先排队，先处理   ---> 喝酒   --->先进去，先出来，后进去，后出来
     数组 :  查找快:因为底层有索引，并且是连续
            增删慢: 数组的长度的是固定的，当我们在进行增删时，会创建一个新的数组，并且将老数组中的值拷贝到新数组中
     链表：  查找慢（底层是链表，两两相连，依次往下找，直到找到为止） --->linkedList 采用二分法查找 
            增删快 :原因在于他仅仅只需要改变相邻元素的地址值
- - - 

###  数据的存储结构
* A:数据的存储结构
    * a:栈结构:后进先出/先进后出(手枪弹夹) FILO (first in last out)
    * b:队列结构:先进先出/后进后出(银行排队) FIFO(first in first out)
    * c:数组结构:
        ```
               查询快:通过索引快速找到元素
               增删慢:每次增删都需要开辟新的数组,将老数组中的元素拷贝到新数组中
                      开辟新数组耗费资源
        ```
    * d:链表结构
        ```
               查询慢:每次都需要从链头或者链尾找起
               增删快:只需要修改元素记录的下个元素的地址值即可不需要移动大量元素
        ```
- - - 

###  ArrayList集合的自身特点
* A:ArrayList集合的自身特点
    * 底层采用的是数组结构
    ```java
     ArrayList al=new ArrayList();//创建了一个长度为0的Object类型数组
     al.add("abc");//底层会创建一个长度为10的Object数组 Object[] obj=new Object[10]
                   //obj[0]="abc"
                  //如果添加的元素的超过10个,底层会开辟一个1.5*10的长度的新数组
                  //把原数组中的元素拷贝到新数组,再把最后一个元素添加到新数组中
   原数组:
     a b c d e f g h k l
   添加m:
     a b c d e f g h k l m null null null null
    ```
- - - 

###  LinkedList集合的自身特点
* A:LinkedList集合的自身特点
    * 底层采用链表结构,每次查询都要从链头或链尾找起,查询相对数组较慢
     但是删除直接修改元素记录的地址值即可,不要大量移动元素
     
    * LinkedList的索引决定是从链头开始找还是从链尾开始找
     如果该元素小于元素长度一半,从链头开始找起,如果大于元素长度的一半,则从链尾找起
- - - 

###  LinkedList特有方法
* A:LinkedList特有方法:获取,添加,删除
	```java
    /*
     *  LinkedList 链表集合的特有功能
     *    自身特点: 链表底层实现,查询慢,增删快
     *  
     *  子类的特有功能,不能多态调用
     */
    public class LinkedListDemo {
      public static void main(String[] args) {
        function_3();
      }


      /*
       *  E removeFirst() 移除并返回链表的开头
       *  E removeLast() 移除并返回链表的结尾
       */
      public static void function_3(){
        LinkedList<String> link = new LinkedList<String>();
        link.add("1");
        link.add("2");
        link.add("3");
        link.add("4");
        
        String first = link.removeFirst();
        String last = link.removeLast();
        System.out.println(first);
        System.out.println(last);
      
        System.out.println(link);
      }
      
      /*
       * E getFirst() 获取链表的开头
       * E getLast() 获取链表的结尾
       */
      public static void function_2(){
        LinkedList<String> link = new LinkedList<String>();
        link.add("1");
        link.add("2");
        link.add("3");
        link.add("4");
      
        if(!link.isEmpty()){
          String first = link.getFirst();
          String last = link.getLast();
          System.out.println(first);
          System.out.println(last);
        }
      }
      
      public static void function_1(){
        LinkedList<String> link = new LinkedList<String>();
        link.addLast("a");
        link.addLast("b");
        link.addLast("c");
        link.addLast("d");
        
        link.addFirst("1");
        link.addFirst("2");
        link.addFirst("3");
        System.out.println(link);
      }
      
      /*
       *  addFirst(E) 添加到链表的开头
       *  addLast(E) 添加到链表的结尾
       */
      public static void function(){
        LinkedList<String> link = new LinkedList<String>();
        
        link.addLast("heima");
        
        link.add("abc");
        link.add("bcd");
        
        link.addFirst("itcast");
        System.out.println(link);
        
        
      }
    }
    ```
- - - 

###  Vector类的特点
* A:Vector类的特点

       Vector集合数据存储的结构是数组结构，为JDK中最早提供的集合,它是线程同步的
       Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。
       此接口Enumeration的功能与 Iterator 接口的功能是类似的。
       Vector集合已被ArrayList替代。枚举Enumeration已被迭代器Iterator替代。
- - - 

##  Set接口
- - - 

###  Set接口的特点
* A:Set接口的特点
    * a:它是个不包含重复元素的集合。
    * b:Set集合取出元素的方式可以采用：迭代器、增强for。
    * c:Set集合有多个子类，这里我们介绍其中的HashSet、LinkedHashSet这两个集合。
- - - 

###  Set集合存储和迭代
* A:Set集合存储和迭代
    ```java
      /*
       *  Set接口,特点不重复元素,没索引
       *  
       *  Set接口的实现类,HashSet (哈希表)
       *  特点: 无序集合,存储和取出的顺序不同,没有索引,不存储重复元素
       *  代码的编写上,和ArrayList完全一致
       */
      public class HashSetDemo {
        public static void main(String[] args) {
          Set<String> set = new HashSet<String>();
          set.add("cn");
          set.add("heima");
          set.add("java");
          set.add("java");
          set.add("itcast");
          
          Iterator<String> it = set.iterator();
          while(it.hasNext()){
            System.out.println(it.next());
          }
          System.out.println("==============");
          
          for(String s : set){
            System.out.println(s);
          }
        }
      }
    ```
- - - 
   
###  哈希表的数据结构
* A:哈希表的数据结构:(参见图解)
       
        加载因子:表中填入的记录数/哈希表的长度
        例如:
        加载因子是0.75 代表:
          数组中的16个位置,其中存入16*0.75=12个元素

        如果在存入第十三个(>12)元素,导致存储链子过长,会降低哈希表的性能,那么此时会扩充哈希表(在哈希),底层会开辟一个长度为原长度2倍的数组,把老元素拷贝到新数组中,再把新元素添加数组中
          
        当存入元素数量>哈希表长度*加载因子,就要扩容,因此加载因子决定扩容时机
- - - 

###  字符串对象的哈希值
* A:字符串对象的哈希值
    ```java
      /*
       *  对象的哈希值,普通的十进制整数
       *  父类Object,方法 public int hashCode() 计算结果int整数
       */
      public class HashDemo {
        public static void main(String[] args) {
          Person p = new Person();
          int i = p.hashCode();
          System.out.println(i);
        
          String s1 = new String("abc");
          String s2 = new String("abc");
          System.out.println(s1.hashCode());
          System.out.println(s2.hashCode());
          
          /*System.out.println("重地".hashCode());
          System.out.println("通话".hashCode());*/
        }
      }
     
      //String类重写hashCode()方法
      //字符串都会存储在底层的value数组中{'a','b','c'}
      public int hashCode() {
              int h = hash;//hash初值为0
              if (h == 0 && value.length > 0) {
                  char val[] = value;

                  for (int i = 0; i < value.length; i++) {
                      h = 31 * h + val[i];
                  }
                  hash = h;
              }
              return h;
          }
    ```
- - - 

###  哈希表的存储过程
* A:哈希表的存储过程
    ```java
     public static void main(String[] args) {
        HashSet<String> set = new HashSet<String>();
        set.add(new String("abc"));
        set.add(new String("abc"));
        set.add(new String("bbc"));
        set.add(new String("bbc"));
        System.out.println(set); 
    }
    ```
  存取原理:
    每存入一个新的元素都要走以下三步:

    1.首先调用本类的hashCode()方法算出哈希值

    2.在容器中找是否与新元素哈希值相同的老元素,
      如果没有直接存入
      如果有转到第三步
    
    3.新元素会与该索引位置下的老元素利用equals方法一一对比
      一旦新元素.equals(老元素)返回true,停止对比,说明重复,不再存入
      如果与该索引位置下的老元素都通过equals方法对比返回false,说明没有重复,存入
- - - 

###  哈希表的存储自定义对象
* A:哈希表的存储自定义对象
    ```java
     /*
      *  HashSet集合的自身特点:
      *    底层数据结构,哈希表
      *    存储,取出都比较快
      *    线程不安全,运行速度快
      */
     public class HashSetDemo1 {
      public static void main(String[] args) {
        
        //将Person对象中的姓名,年龄,相同数据,看作同一个对象
        //判断对象是否重复,依赖对象自己的方法 hashCode,equals
        HashSet<Person> setPerson = new HashSet<Person>();
        setPerson.add(new Person("a",11));
        setPerson.add(new Person("b",10));
        setPerson.add(new Person("b",10));
        setPerson.add(new Person("c",25));
        setPerson.add(new Person("d",19));
        setPerson.add(new Person("e",17));//每个对象的地址值都不同,调用Obejct类的hashCode方法返回不同哈希值,直接存入
        System.out.println(setPerson);
      }
     }
    
    public class Person {
      private String name;
      private int age;
      
      public String getName() {
        return name;
      }
      public void setName(String name) {
        this.name = name;
      }
      public int getAge() {
        return age;
      }
      public void setAge(int age) {
        this.age = age;
      }
      public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
      }
      public Person(){}
      
      public String toString(){
        return name+".."+age;
      }

     }
    ```
- - - 
      
###  自定义对象重写hashCode和equals
* A:自定义对象重写hashCode和equals
    ```java
	    /*
          *  HashSet集合的自身特点:
          *    底层数据结构,哈希表
          *    存储,取出都比较快
          *    线程不安全,运行速度快
          */
         public class HashSetDemo1 {
          public static void main(String[] args) {
            
            //将Person对象中的姓名,年龄,相同数据,看作同一个对象
            //判断对象是否重复,依赖对象自己的方法 hashCode,equals
            HashSet<Person> setPerson = new HashSet<Person>();
            setPerson.add(new Person("a",11));
            setPerson.add(new Person("b",10));
            setPerson.add(new Person("b",10));
            setPerson.add(new Person("c",25));
            setPerson.add(new Person("d",19));
            setPerson.add(new Person("e",17));
            System.out.println(setPerson);
          }
         }
        
        public class Person {
          private String name;
          private int age;

          /*
           *  没有做重写父类,每次运行结果都是不同整数
           *  如果子类重写父类的方法,哈希值,自定义的
           *  存储到HashSet集合的依据
           *   
           *  尽可能让不同的属性值产生不同的哈希值,这样就不用再调用equals方法去比较属性
           *
           */
          public int hashCode(){
            return name.hashCode()+age*55;
          }
          //方法equals重写父类,保证和父类相同
          //public boolean equals(Object obj){}
          public boolean equals(Object obj){
            if(this == obj)
              return true;
            if(obj == null)
              return false;
            if(obj instanceof Person){
              Person p = (Person)obj;
              return name.equals(p.name) && age==p.age;
            }
            return false;
          }
          
          public String getName() {
            return name;
          }
          public void setName(String name) {
            this.name = name;
          }
          public int getAge() {
            return age;
          }
          public void setAge(int age) {
            this.age = age;
          }
          public Person(String name, int age) {
            super();
            this.name = name;
            this.age = age;
          }
          public Person(){}
          
          public String toString(){
            return name+".."+age;
          }

         }
    ```
- - - 

###  LinkedHashSet集合
* A:LinkedHashSet集合
    ```java
    /*
     *   LinkedHashSet 基于链表的哈希表实现
     *   继承自HashSet
     *   
     *   LinkedHashSet 自身特性,具有顺序,存储和取出的顺序相同的
     *   线程不安全的集合,运行速度块
     */
    public class LinkedHashSetDemo {
      
      public static void main(String[] args) {
        LinkedHashSet<Integer> link = new LinkedHashSet<Integer>();
        link.add(123);
        link.add(44);
        link.add(33);
        link.add(33);
        link.add(66);
        link.add(11);
        System.out.println(link);
      }
    }
    ```
- - - 

##  判断集合唯一性原理
- - - 

###  ArrayList,HashSet判断对象是否重复的原因
* A:ArrayList,HashSet判断对象是否重复的原因
    * a:ArrayList的contains方法原理:底层依赖于equals方法
       ArrayList的contains方法会使用调用方法时，
         传入的元素的equals方法依次与集合中的旧元素所比较，
         从而根据返回的布尔值判断是否有重复元素。
         此时，当ArrayList存放自定义类型时，由于自定义类型在未重写equals方法前，
         判断是否重复的依据是地址值，所以如果想根据内容判断是否为重复元素，需要重写元素的equals方法。
    
    * b:HashSet的add()方法和contains方法()底层都依赖 hashCode()方法与equals方法()

      Set集合不能存放重复元素，其添加方法在添加时会判断是否有重复元素，有重复不添加，没重复则添加。
      HashSet集合由于是无序的，其判断唯一的依据是元素类型的hashCode与equals方法的返回结果。规则如下：
      先判断新元素与集合内已经有的旧元素的HashCode值
      * 如果不同，说明是不同元素，添加到集合。
      * 如果相同，再判断equals比较结果。返回true则相同元素；返回false则不同元素，添加到集合。
      所以，使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法，则判断重复时，使用的是地址值，如果想通过内容比较元素是否相同，需要重写该元素类的hashcode与equals方法。
- - - 
 
###  hashCode和equals方法的面试题 
* A:hashCode和equals的面试题
```java
 /*
  *   两个对象  Person  p1 p2
  *   问题: 如果两个对象的哈希值相同 p1.hashCode()==p2.hashCode()
  *        两个对象的equals一定返回true吗  p1.equals(p2) 一定是true吗
  *        正确答案:不一定
  *        
  *        如果两个对象的equals方法返回true,p1.equals(p2)==true
  *        两个对象的哈希值一定相同吗
  *        正确答案: 一定
  */  
 在 Java 应用程序执行期间，
 1.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 
 2.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。 
    
    两个对象不同(对象属性值不同) equals返回false=====>两个对象调用hashCode()方法哈希值相同
    
    两个对象调用hashCode()方法哈希值不同=====>equals返回true


    两个对象不同(对象属性值不同) equals返回false=====>两个对象调用hashCode()方法哈希值不同
    
    两个对象调用hashCode()方法哈希值相同=====>equals返回true
   
   所以说两个对象哈希值无论相同还是不同,equals都可能返回true
```   
- - - 

##  Map接口
- - - 

###  Map集合概述
* A:Map集合概述:
    我们通过查看Map接口描述,发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同
    * a:Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。
    	
    * b:Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。
    ```
    	Collection中的集合称为单列集合，Map中的集合称为双列集合。
    	需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。
    
        Map
        |--HashMap
        |--LinkedHashMap
    ```
- - - 

###  Map接口中的常用方法 
* A:Map接口中的常用方法 
    ```java
       /*
        *  Map接口中的常用方法
        *    使用Map接口的实现类 HashMap
        */
       public class MapDemo {
       	public static void main(String[] args) {
       		function_2();
       	}
       	/*
       	 *  移除集合中的键值对,返回被移除之前的值
       	 *  V remove(K)
       	 */
       	public static void function_2(){
       		Map<Integer,String> map = new HashMap<Integer, String>();
       		map.put(1, "a");
       		map.put(2, "b");
       		map.put(3, "c");
       		System.out.println(map);
       		
       		String value = map.remove(33);
       		System.out.println(value);
       		System.out.println(map);
       	}
       	
       	/*
       	 * 通过键对象,获取值对象
       	 * V get(K)
       	 * 如果集合中没有这个键,返回null
       	 */
       	public static void function_1(){
       		//创建集合对象,作为键的对象整数,值的对象存储字符串
       		Map<Integer,String> map = new HashMap<Integer, String>();
       		map.put(1, "a");
       		map.put(2, "b");
       		map.put(3, "c");
       		System.out.println(map);
       		
       		String value = map.get(4);
       		System.out.println(value);
       	}
       	
       	/*
       	 *  将键值对存储到集合中
       	 *  V put(K,V) K 作为键的对象, V作为值的对象
       	 *  存储的是重复的键,将原有的值,覆盖
       	 *  返回值一般情况下返回null,
       	 *  存储重复键的时候,返回被覆盖之前的值
       	 */
       	public static void function(){
       		//创建集合对象,HashMap,存储对象,键是字符串,值是整数
       		Map<String, Integer> map = new HashMap<String, Integer>();
       		map.put("a", 1);
       		
       		map.put("b", 2);
       		
       		map.put("c", 3);
       		
       		System.out.println(map);
       	}
       }
    ```
- - - 

###  Map集合遍历方式keySet方法
* A:Map集合遍历方式keySet方法
```java
     1.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键
     2.遍历键的Set集合，得到每一个键
     3.根据键利用get(key)去Map找所对应的值
     /*
      *  Map集合的遍历
      *    利用键获取值
      *    Map接口中定义方法keySet
      *    所有的键,存储到Set集合
      */
     public class MapDemo1 {
     	public static void main(String[] args) {
     		/*
     		 *  1. 调用map集合的方法keySet,所有的键存储到Set集合中
     		 *  2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)
     		 *  3. 调用map集合方法get,通过键获取到值
     		 */
     		Map<String,Integer> map = new HashMap<String,Integer>();
     		map.put("a", 11);
     		map.put("b", 12);
     		map.put("c", 13);
     		map.put("d", 14);
     		
     		//1. 调用map集合的方法keySet,所有的键存储到Set集合中
     		Set<String> set = map.keySet();
     		//2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)
     		Iterator<String> it = set.iterator();
     		while(it.hasNext()){
     			//it.next返回是Set集合元素,也就是Map中的键
     			//3. 调用map集合方法get,通过键获取到值
     			String key = it.next();
     			Integer value = map.get(key);
     			System.out.println(key+"...."+value);
     		}
     		
     		System.out.println("=======================");
     		

     		for(String key : map.keySet()){
     			Integer value = map.get(key);
     			System.out.println(key+"...."+value);
     		}
     	}
     }
``` 
- - - 

###  Map集合Entry对象
* A:Map集合Entry对象
```java
     interface Map{
     	interface Entry{//Entry是Map的一个内部接口
     		           //由Map的子类的内部类实现

     	}
     }
     class HashMap{
     	static class Entry<K,V> implements Map.Entry<K,V> {//Entry对象指的就是该类的对象
            final K key;
                  V value;
     	}
     }
     在Map类设计时，提供了一个嵌套接口：Entry。
     Entry将键值对的对应关系封装成了对象。
     即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。
       a:Entry是Map接口中提供的一个静态内部嵌套接口。
       b:相关方法
     	getKey()方法：获取Entry对象中的键
        getValue()方法：获取Entry对象中的值
        entrySet()方法：用于返回Map集合中所有的键值对(Entry)对象，以Set集合形式返回。
```
- - - 

###  Map集合遍历方式entrySet方法 
* A:Map集合遍历方式entrySet方法
```java
     /*
     *  Map集合获取方式
     *  entrySet方法,键值对映射关系(结婚证)获取
     *  实现步骤:
     *    1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合
     *        Set<Entry <K,V> >
     *    2. 迭代Set集合
     *    3. 获取出的Set集合的元素,是映射关系对象
     *    4. 通过映射关系对象方法 getKet, getValue获取键值对
     *    
     *    创建内部类对象 外部类.内部类 = new 
     */
    public class MapDemo2 {
    	public static void main(String[] args) {
    		Map<Integer,String> map = new HashMap<Integer, String>();
    		map.put(1, "abc");
    		map.put(2, "bcd");
    		map.put(3, "cde");
    		//1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合
    		Set<Map.Entry <Integer,String> >  set = map.entrySet();
    		//2. 迭代Set集合
    		Iterator<Map.Entry <Integer,String> > it = set.iterator();
    		while(it.hasNext()){
    			//  3. 获取出的Set集合的元素,是映射关系对象
    			// it.next 获取的是什么对象,也是Map.Entry对象
    			Map.Entry<Integer, String> entry = it.next();
    			//4. 通过映射关系对象方法 getKet, getValue获取键值对
    			Integer key = entry.getKey();
    			String value = entry.getValue();
    			System.out.println(key+"...."+value);
    		}
    		
    		 
    	}
    }
```
- - - 

###  Map集合遍历方式增强for循环
* A:Map集合遍历方式增强for循环
    * A:Map集合遍历方式entrySet方法
    ```java
       /*
       *  Map集合获取方式
       *  entrySet方法,键值对映射关系(结婚证)获取
       *  实现步骤:
       *    1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合
       *        Set<Entry <K,V> >
       *    2. 迭代Set集合
       *    3. 获取出的Set集合的元素,是映射关系对象
       *    4. 通过映射关系对象方法 getKet, getValue获取键值对
       *    
       *    创建内部类对象 外部类.内部类 = new 
       */
      public class MapDemo2 {
      	public static void main(String[] args) {
      		Map<Integer,String> map = new HashMap<Integer, String>();
      		map.put(1, "abc");
      		map.put(2, "bcd");
      		map.put(3, "cde");
      		//1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合
      		Set<Map.Entry <Integer,String> >  set = map.entrySet();
      		//2. 迭代Set集合
      		Iterator<Map.Entry <Integer,String> > it = set.iterator();
      		while(it.hasNext()){
      			//  3. 获取出的Set集合的元素,是映射关系对象
      			// it.next 获取的是什么对象,也是Map.Entry对象
      			Map.Entry<Integer, String> entry = it.next();
      			//4. 通过映射关系对象方法 getKet, getValue获取键值对
      			Integer key = entry.getKey();
      			String value = entry.getValue();
      			System.out.println(key+"...."+value);
      		}
      		
      		System.out.println("=========================");
      		for(Map.Entry<Integer, String> entry : map.entrySet()){
      			System.out.println(entry.getKey()+"..."+entry.getValue());
      		}
      	}
      }
      
      注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。
    ```
- - - 

###  HashMap集合存储和遍历
* A:HashMap集合存储和遍历
```java
     /*
      *  使用HashMap集合,存储自定义的对象
      *  自定义对象,作为键,出现,作为值出现
      */
     public class HashMapDemo {
     	public static void main(String[] args) {
     		function_1();
     	}
     	/*
     	 * HashMap 存储自定义对象Person,作为键出现
     	 * 键的对象,是Person类型,值是字符串
     	 * 保证键的唯一性,存储到键的对象,重写hashCode equals
     	 */
     	public static void function_1(){
     		HashMap<Person, String> map = new HashMap<Person, String>();
     		map.put(new Person("a",20), "里约热内卢");
     		map.put(new Person("b",18), "索马里");
     		map.put(new Person("b",18), "索马里");
     		map.put(new Person("c",19), "百慕大");
     		for(Person key : map.keySet()){
     			String value = map.get(key);
     			System.out.println(key+"..."+value);
     		}
     		System.out.println("===================");
     		for(Map.Entry<Person, String> entry : map.entrySet()){
     			System.out.println(entry.getKey()+"..."+entry.getValue());
     		}
     	}
     	
     	/*
     	 * HashMap 存储自定义的对象Person,作为值出现
     	 * 键的对象,是字符串,可以保证唯一性
     	 */
     	public static void function(){
     		HashMap<String, Person> map = new HashMap<String, Person>();
     		map.put("beijing", new Person("a",20));
     		map.put("tianjin", new Person("b",18));
     		map.put("shanghai", new Person("c",19));
     		for(String key : map.keySet()){
     			Person value = map.get(key);
     			System.out.println(key+"..."+value);
     		}
     		System.out.println("=================");
     		for(Map.Entry<String, Person> entry : map.entrySet()){
     			String key = entry.getKey();
     			Person value = entry.getValue();
     			System.out.println(key+"..."+value);
     		}
     	}
     }
```
- - - 

###  LinkedHashMap的特点
* A:LinkedHashMap的特点
```java
	  /*
	   *  LinkedHashMap继承HashMap
	   *  保证迭代的顺序
	   */
	  public class LinkedHashMapDemo {
	  	public static void main(String[] args) {
	  		LinkedHashMap<String, String> link = new LinkedHashMap<String, String>();
	  		link.put("1", "a");
	  		link.put("13", "a");
	  		link.put("15", "a");
	  		link.put("17", "a");
	  		System.out.println(link);
	  	}
	  }
```
- - - 

###  Hashtable的特点
* A:Hashtable的特点
    ```java
	   /*
	    *  Map接口实现类 Hashtable
	    *  底层数据结果哈希表,特点和HashMap是一样的
	    *  Hashtable 线程安全集合,运行速度慢
	    *  HashMap 线程不安全的集合,运行速度快
	    *  
	    *  Hashtable命运和Vector是一样的,从JDK1.2开始,被更先进的HashMap取代
	    *  
	    *  HashMap 允许存储null值,null键
	    *  Hashtable 不允许存储null值,null键
	    *  
	    *  Hashtable他的孩子,子类 Properties 依然活跃在开发舞台
	    */
	   public class HashtableDemo {
	   	public static void main(String[] args) {	
	   		Map<String,String> map = new Hashtable<String,String>();
	   		map.put(null, null);
	   		System.out.println(map);
	   	}
	   }
    ```
- - - 

###  静态导入
* A:静态导入:如果本类中有和静态导入的同名方法会优先使用本类的
               如果还想使用静态导入的,依然需要类名来调用
    ```java
	   /*
	    * JDK1.5新特性,静态导入
	    * 减少开发的代码量
	    * 标准的写法,导入包的时候才能使用
	    * 
	    * import static java.lang.System.out;最末尾,必须是一个静态成员
	    */
	   import static java.lang.System.out;
	   import static java.util.Arrays.sort;

	   public class StaticImportDemo {
	   	public static void main(String[] args) {
	   		out.println("hello");
	   		
	   		int[] arr = {1,4,2};
	   		sort(arr);
	   	}
	   }
    ```
- - - 

###  方法的可变参数
* A:方法的可变参数
    ```java 
     /*
      *  JDK1.5新的特性,方法的可变参数
      *  前提: 方法参数数据类型确定,参数的个数任意
      *  可变参数语法: 数据类型...变量名
      *  可变参数,本质就是一个数组
      */
     public class VarArgumentsDemo {
     	public static void main(String[] args) {
     		//调用一个带有可变参数的方法,传递参数,可以任意
     	//	getSum();
     		int sum = getSum(5,34,3,56,7,8,0);
     		System.out.println(sum);
 
     	}
     
     	/*
     	 * 定义方法,计算10个整数和
     	 * 方法的可变参数实现
     	 */
     	public static int getSum(int...a){
     		int sum = 0 ;
     		for(int i : a){
     			sum = sum + i;
     		}
     		return sum;
     	}
     	
     	/*
     	 * 定义方法,计算3个整数和
     	 */
     	/*public static int getSum(int a,int b ,int c){
     		return a+b+c;
     	}*/
     	
     	/*
     	 * 定义方法,计算2个整数和
     	 */
     	/*public static int getSum(int a,int b){
     		return a+b;
     	}*/
     }
    ```
- - - 

###  可变参数的注意事项
* A:可变参数的注意事项    
    ```java
	   /*
	    * 可变参数的注意事项
	    * 1. 一个方法中,可变参数只能有一个
	    * 2. 可变参数,必须写在参数列表的最后一位
	    */
	    public static void function(Object...o){
	   	 
	    }
    ```
- - - 

###   Collections工具类
* A:Collections工具类
    ```java
      /*
       *  集合操作的工具类
       *    Collections
       */
      public class CollectionsDemo {
      	public static void main(String[] args) {
      		function_2();
      	}
      	/*
      	 * Collections.shuffle方法
      	 * 对List集合中的元素,进行随机排列
      	 */
      	public static void function_2(){
      		List<Integer> list = new ArrayList<Integer>();
      		list.add(1);
      		list.add(5);
      		list.add(9);
      		list.add(11);
      		list.add(8);
      		list.add(10);
      		list.add(15);
      		list.add(20);	
      		System.out.println(list);
      		
      		//调用工具类方法shuffle对集合随机排列
      		Collections.shuffle(list);
      		System.out.println(list);
      	}
      	
      	/*
      	 * Collections.binarySearch静态方法
      	 * 对List集合进行二分搜索,方法参数,传递List集合,传递被查找的元素
      	 */
      	public static void function_1(){
      		List<Integer> list = new ArrayList<Integer>();
      		list.add(1);
      		list.add(5);
      		list.add(8);
      		list.add(10);
      		list.add(15);
      		list.add(20);
      		//调用工具类静态方法binarySearch
      		int index = Collections.binarySearch(list, 16);
      		System.out.println(index);
      	}
      	
      	/*
      	 *  Collections.sort静态方法
      	 *  对于List集合,进行升序排列
      	 */
      	public static void function(){
      		//创建List集合
      		List<String> list = new ArrayList<String>();
      		list.add("ewrew");
      		list.add("qwesd");
      		list.add("Qwesd");
      		list.add("bv");
      		list.add("wer");
      		System.out.println(list);
      		//调用集合工具类的方法sort
      		Collections.sort(list);
      		System.out.println(list);
      	}
      }
    ```
- - - 

###  集合的嵌套
* A:集合的嵌套
```java
    /*
     *  Map集合的嵌套,Map中存储的还是Map集合
     *  要求:
     *    传智播客  
     *      Java基础班
     *        001  张三
     *        002  李四
     *      
     *      Java就业班
     *        001  王五
     *        002  赵六
     *  对以上数据进行对象的存储
     *   001 张三  键值对
     *   Java基础班: 存储学号和姓名的键值对
     *   Java就业班:
     *   传智播客: 存储的是班级
     *   
     *   基础班Map   <学号,姓名>
     *   传智播客Map  <班级名字, 基础班Map>
     */
    public class MapMapDemo {
    	public static void main(String[] args) {
    		//定义基础班集合
    		HashMap<String, String> javase = new HashMap<String, String>();
    		//定义就业班集合
    		HashMap<String, String> javaee = new HashMap<String, String>();
    		//向班级集合中,存储学生信息
    		javase.put("001", "张三");
    		javase.put("002", "李四");
    		
    		javaee.put("001", "王五");
    		javaee.put("002", "赵六");
    		//定义传智播客集合容器,键是班级名字,值是两个班级容器
    		HashMap<String, HashMap<String,String>> czbk =
    				new HashMap<String, HashMap<String,String>>();
    		czbk.put("基础班", javase);
    		czbk.put("就业班", javaee);
    		
    		 keySet(czbk);
    		 
    	}
    }    
```
- - - 

###  集合的嵌套keySet遍历
* A:集合的嵌套keySet遍历
	```java
       /*
	    *  Map集合的嵌套,Map中存储的还是Map集合
	    *  要求:
	    *    传智播客  
	    *      Java基础班
	    *        001  张三
	    *        002  李四
	    *      
	    *      Java就业班
	    *        001  王五
	    *        002  赵六
	    *  对以上数据进行对象的存储
	    *   001 张三  键值对
	    *   Java基础班: 存储学号和姓名的键值对
	    *   Java就业班:
	    *   传智播客: 存储的是班级
	    *   
	    *   基础班Map   <学号,姓名>
	    *   传智播客Map  <班级名字, 基础班Map>
	    */
	   public class MapMapDemo {
	   	public static void main(String[] args) {
	   		//定义基础班集合
	   		HashMap<String, String> javase = new HashMap<String, String>();
	   		//定义就业班集合
	   		HashMap<String, String> javaee = new HashMap<String, String>();
	   		//向班级集合中,存储学生信息
	   		javase.put("001", "张三");
	   		javase.put("002", "李四");
	   		
	   		javaee.put("001", "王五");
	   		javaee.put("002", "赵六");
	   		//定义传智播客集合容器,键是班级名字,值是两个班级容器
	   		HashMap<String, HashMap<String,String>> czbk =
	   				new HashMap<String, HashMap<String,String>>();
	   		czbk.put("基础班", javase);
	   		czbk.put("就业班", javaee);
	   		
	   		 keySet(czbk);
	   		 
	   	}
	   	
	   	 
	   	
	   	public static void keySet(HashMap<String,HashMap<String,String>> czbk){
	   		//调用czbk集合方法keySet将键存储到Set集合
	   		Set<String> classNameSet = czbk.keySet();
	   		//迭代Set集合
	   		Iterator<String> classNameIt = classNameSet.iterator();
	   		while(classNameIt.hasNext()){
	   			//classNameIt.next获取出来的是Set集合元素,czbk集合的键
	   			String classNameKey = classNameIt.next();
	   			//czbk集合的方法get获取值,值是一个HashMap集合
	   			HashMap<String,String> classMap = czbk.get(classNameKey);
	   			//调用classMap集合方法keySet,键存储到Set集合
	   			Set<String> studentNum = classMap.keySet();
	   			Iterator<String> studentIt = studentNum.iterator();
	   	   
	        	   while(studentIt.hasNext()){
	   				//studentIt.next获取出来的是classMap的键,学号
	   				String numKey = studentIt.next();
	   				//调用classMap集合中的get方法获取值
	   				String nameValue = classMap.get(numKey);
	   				System.out.println(classNameKey+".."+numKey+".."+nameValue);
	   			}
	   		}
	   		
	   		System.out.println("==================================");
	   	    for(String className: czbk.keySet()){
	   	       HashMap<String, String> hashMap = czbk.get(className);	
	   	       for(String numKey : hashMap.keySet()){
	   	    	   String nameValue = hashMap.get(numKey);
	   	    	   System.out.println(className+".."+numKey+".."+nameValue);
	   	       }
	   	    }
	   	}

	   } 
    ```      
- - - 

###  集合的嵌套entrySet遍历
* A:集合的嵌套entrySet遍历
```java    
    /*
     *  Map集合的嵌套,Map中存储的还是Map集合
     *  要求:
     *    传智播客  
     *      Java基础班
     *        001  张三
     *        002  李四
     *      
     *      Java就业班
     *        001  王五
     *        002  赵六
     *  对以上数据进行对象的存储
     *   001 张三  键值对
     *   Java基础班: 存储学号和姓名的键值对
     *   Java就业班:
     *   传智播客: 存储的是班级
     *   
     *   基础班Map   <学号,姓名>
     *   传智播客Map  <班级名字, 基础班Map>
     */
    public class MapMapDemo {
    	public static void main(String[] args) {
    		//定义基础班集合
    		HashMap<String, String> javase = new HashMap<String, String>();
    		//定义就业班集合
    		HashMap<String, String> javaee = new HashMap<String, String>();
    		//向班级集合中,存储学生信息
    		javase.put("001", "张三");
    		javase.put("002", "李四");
    		
    		javaee.put("001", "王五");
    		javaee.put("002", "赵六");
    		//定义传智播客集合容器,键是班级名字,值是两个班级容器
    		HashMap<String, HashMap<String,String>> czbk =
    				new HashMap<String, HashMap<String,String>>();
    		czbk.put("基础班", javase);
    		czbk.put("就业班", javaee);
    		
    		entrySet(czbk);
    	}
    	
    	public static void entrySet(HashMap<String,HashMap<String,String>> czbk){
    		//调用czbk集合方法entrySet方法,将czbk集合的键值对关系对象,存储到Set集合
    		Set<Map.Entry<String, HashMap<String,String>>> 
    		                         classNameSet = czbk.entrySet();
    		//迭代器迭代Set集合
    		Iterator<Map.Entry<String, HashMap<String,String>>> classNameIt = classNameSet.iterator();
    		while(classNameIt.hasNext()){
    			//classNameIt.next方法,取出的是czbk集合的键值对关系对象
    			Map.Entry<String, HashMap<String,String>> classNameEntry =  classNameIt.next();
    			//classNameEntry方法 getKey,getValue
    			String classNameKey = classNameEntry.getKey();
    			//获取值,值是一个Map集合
    			HashMap<String,String> classMap = classNameEntry.getValue();
    			//调用班级集合classMap方法entrySet,键值对关系对象存储Set集合
    			Set<Map.Entry<String, String>> studentSet = classMap.entrySet();
    			//迭代Set集合
    			Iterator<Map.Entry<String, String>> studentIt = studentSet.iterator();
    			while(studentIt.hasNext()){
    				//studentIt方法next获取出的是班级集合的键值对关系对象
    				Map.Entry<String, String> studentEntry = studentIt.next();
    				//studentEntry方法 getKey getValue
    				String numKey = studentEntry.getKey();
    				String nameValue = studentEntry.getValue();
    				System.out.println(classNameKey+".."+numKey+".."+nameValue);
    			}
    		}
    	     System.out.println("==================================");
    		
    		for (Map.Entry<String, HashMap<String, String>> me : czbk.entrySet()) {
    			String classNameKey = me.getKey();
    			HashMap<String, String> numNameMapValue = me.getValue();
    			for (Map.Entry<String, String> nameMapEntry : numNameMapValue.entrySet()) {
    				String numKey = nameMapEntry.getKey();
    				String nameValue = nameMapEntry.getValue();
    				System.out.println(classNameKey + ".." + numKey + ".." + nameValue);
    			}
    		}
    	}
    	
    
    }
```
- - - 

##  模拟斗地主洗牌发牌
- - - 

###  斗地主的功能分析
* A:斗地主的功能分析
	* a:具体规则：
        ```
		   	1. 组装54张扑克牌
		    2. 将54张牌顺序打乱
		   	3. 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。
		   	4. 查看三人各自手中的牌（按照牌的大小排序）、底牌
        ```    
    * b:分析:
        ```
	      1.准备牌：
	       完成数字与纸牌的映射关系：
	       使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。
	      2.洗牌：
	       通过数字完成洗牌发牌
	      3.发牌：
	       将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。
	       存放的过程中要求数字大小与斗地主规则的大小对应。
	       将代表不同纸牌的数字分配给不同的玩家与底牌。
	      4.看牌：
	       通过Map集合找到对应字符展示。
	       通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。
        ```
- - - 

###  斗地主的准备牌
* A:斗地主的准备牌
    ```java
     /*
      *  实现模拟斗地主的功能
      *   1. 组合牌
      *   2. 洗牌
      *   3. 发牌
      *   4. 看牌
      */
     public class DouDiZhu {
     	public static void main(String[] args) {
     		//1. 组合牌
     		//创建Map集合,键是编号,值是牌
     		HashMap<Integer,String> pooker = new HashMap<Integer, String>();
     		//创建List集合,存储编号
     		ArrayList<Integer> pookerNumber = new ArrayList<Integer>();
     		//定义出13个点数的数组
     		String[] numbers = {"2","A","K","Q","J","10","9","8","7","6","5","4","3"};
     		//定义4个花色数组
     		String[] colors = {"♠","♥","♣","♦"};
     		//定义整数变量,作为键出现
     		int index = 2;
     		//遍历数组,花色+点数的组合,存储到Map集合
     		for(String number : numbers){
     			for(String color : colors){
     				pooker.put(index, color+number);
     				pookerNumber.add(index);
     				index++;
     			}
     		}
     		//存储大王,和小王,索引是从0~54,对应大王,小王,...3(牌的顺序从大到小)
     		pooker.put(0, "大王");
     		pookerNumber.add(0);
     		pooker.put(1, "小王");
     		pookerNumber.add(1);
     	 
        }
    }    
    ```
- - - 

###  斗地主的洗牌
* A:斗地主的洗牌
	```java
      /*
	   *  实现模拟斗地主的功能
	   *   1. 组合牌
	   *   2. 洗牌
	   *   3. 发牌
	   *   4. 看牌
	   */
	  public class DouDiZhu {
	  	public static void main(String[] args) {
	  		//1. 组合牌
	  		//创建Map集合,键是编号,值是牌
	  		HashMap<Integer,String> pooker = new HashMap<Integer, String>();
	  		//创建List集合,存储编号
	  		ArrayList<Integer> pookerNumber = new ArrayList<Integer>();
	  		//定义出13个点数的数组
	  		String[] numbers = {"2","A","K","Q","J","10","9","8","7","6","5","4","3"};
	  		//定义4个花色数组
	  		String[] colors = {"♠","♥","♣","♦"};
	  		//定义整数变量,作为键出现
	  		int index = 2;
	  		//遍历数组,花色+点数的组合,存储到Map集合
	  		for(String number : numbers){
	  			for(String color : colors){
	  				pooker.put(index, color+number);
	  				pookerNumber.add(index);
	  				index++;
	  			}
	  		}
	  		//存储大王,和小王
	  		pooker.put(0, "大王");
	  		pookerNumber.add(0);
	  		pooker.put(1, "小王");
	  		pookerNumber.add(1);
	  		
	  		//洗牌,将牌的编号打乱
	  		Collections.shuffle(pookerNumber);
	  		
	  	 
	  	}
	  	 
	  }
    ```
- - - 

###  斗地主的发牌
* A:斗地主的发牌
    ```java
    /*
     *  实现模拟斗地主的功能
     *   1. 组合牌
     *   2. 洗牌
     *   3. 发牌
     *   4. 看牌
     */
    public class DouDiZhu {
    	public static void main(String[] args) {
    		//1. 组合牌
    		//创建Map集合,键是编号,值是牌
    		HashMap<Integer,String> pooker = new HashMap<Integer, String>();
    		//创建List集合,存储编号
    		ArrayList<Integer> pookerNumber = new ArrayList<Integer>();
    		//定义出13个点数的数组
    		String[] numbers = {"2","A","K","Q","J","10","9","8","7","6","5","4","3"};
    		//定义4个花色数组
    		String[] colors = {"♠","♥","♣","♦"};
    		//定义整数变量,作为键出现
    		int index = 2;
    		//遍历数组,花色+点数的组合,存储到Map集合
    		for(String number : numbers){
    			for(String color : colors){
    				pooker.put(index, color+number);
    				pookerNumber.add(index);
    				index++;
    			}
    		}
    		//存储大王,和小王
    		pooker.put(0, "大王");
    		pookerNumber.add(0);
    		pooker.put(1, "小王");
    		pookerNumber.add(1);
    		
    		//洗牌,将牌的编号打乱
    		Collections.shuffle(pookerNumber);
    		
    		//发牌功能,将牌编号,发给玩家集合,底牌集合
    		ArrayList<Integer> player1 = new ArrayList<Integer>();
    		ArrayList<Integer> player2 = new ArrayList<Integer>();
    		ArrayList<Integer> player3 = new ArrayList<Integer>();
    		ArrayList<Integer> bottom = new ArrayList<Integer>();
    		
    		//发牌采用的是集合索引%3
    		for(int i = 0 ; i < pookerNumber.size() ; i++){
    			//先将底牌做好
    			if(i < 3){
    				//存到底牌去
    				bottom.add( pookerNumber.get(i));
    			   //对索引%3判断
    			}else if(i % 3 == 0){
    				//索引上的编号,发给玩家1
    				player1.add( pookerNumber.get(i) );
    			}else if( i % 3 == 1){
    				//索引上的编号,发给玩家2
    				player2.add( pookerNumber.get(i) );
    			}else if( i % 3 == 2){
    				//索引上的编号,发给玩家3
    				player3.add( pookerNumber.get(i) );
    			}
    		}
    		 
    	}
    	 
    }
    ```
- - - 
    
###  斗地主的看牌
* A:斗地主的看牌
    ```java
     /*
      *  实现模拟斗地主的功能
      *   1. 组合牌
      *   2. 洗牌
      *   3. 发牌
      *   4. 看牌
      */
     public class DouDiZhu {
     	public static void main(String[] args) {
     		//1. 组合牌
     		//创建Map集合,键是编号,值是牌
     		HashMap<Integer,String> pooker = new HashMap<Integer, String>();
     		//创建List集合,存储编号
     		ArrayList<Integer> pookerNumber = new ArrayList<Integer>();
     		//定义出13个点数的数组
     		String[] numbers = {"2","A","K","Q","J","10","9","8","7","6","5","4","3"};
     		//定义4个花色数组
     		String[] colors = {"♠","♥","♣","♦"};
     		//定义整数变量,作为键出现
     		int index = 2;
     		//遍历数组,花色+点数的组合,存储到Map集合
     		for(String number : numbers){
     			for(String color : colors){
     				pooker.put(index, color+number);
     				pookerNumber.add(index);
     				index++;
     			}
     		}
     		//存储大王,和小王
     		pooker.put(0, "大王");
     		pookerNumber.add(0);
     		pooker.put(1, "小王");
     		pookerNumber.add(1);
     		
     		//洗牌,将牌的编号打乱
     		Collections.shuffle(pookerNumber);
     		
     		//发牌功能,将牌编号,发给玩家集合,底牌集合
     		ArrayList<Integer> player1 = new ArrayList<Integer>();
     		ArrayList<Integer> player2 = new ArrayList<Integer>();
     		ArrayList<Integer> player3 = new ArrayList<Integer>();
     		ArrayList<Integer> bottom = new ArrayList<Integer>();
     		
     		//发牌采用的是集合索引%3
     		for(int i = 0 ; i < pookerNumber.size() ; i++){
     			//先将底牌做好
     			if(i < 3){
     				//存到底牌去
     				bottom.add( pookerNumber.get(i));
     			   //对索引%3判断
     			}else if(i % 3 == 0){
     				//索引上的编号,发给玩家1
     				player1.add( pookerNumber.get(i) );
     			}else if( i % 3 == 1){
     				//索引上的编号,发给玩家2
     				player2.add( pookerNumber.get(i) );
     			}else if( i % 3 == 2){
     				//索引上的编号,发给玩家3
     				player3.add( pookerNumber.get(i) );
     			}
     		}
     		//对玩家手中的编号排序
     		Collections.sort(player1);
     		Collections.sort(player2);
     		Collections.sort(player3);
     		//看牌,将玩家手中的编号,到Map集合中查找,根据键找值
     		//定义方法实现
     		look("刘德华",player1,pooker);
     		look("张曼玉",player2,pooker);
     		look("林青霞",player3,pooker);
     		look("底牌",bottom,pooker);
     	}
     	public static void look(String name,ArrayList<Integer> player,HashMap<Integer,String> pooker){
     		//遍历ArrayList集合,获取元素,作为键,到集合Map中找值
     		System.out.print(name+" ");
     		for(Integer key : player){
     			String value = pooker.get(key);
     			System.out.print(value+" ");
     		}
     		System.out.println();
     	}
     }
    ```

